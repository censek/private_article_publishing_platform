![ ](https://upload-images.jianshu.io/upload_images/20571728-d325b7c351c21162.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 第一章 · 注重实效的哲学
注重实效的程序员能够越出直接的问题去思考，总是设法把问题放在更大的语境中，总是设法注意更大的图景。

**关心你的技艺。**<br>
**思考！你的工作。**

#### 1. 我的源码让猫给吃了
对你的职业生涯负责，并且不害怕承认无知或错误。<br>
当你犯错误、或是判断失误时，诚实地承认它，并**设法给出各种选择**。**不要责备别人或别的东西，或是拼凑借口**。

#### 2. 软件的熵
**不要容忍破窗户。**<br>
不要留着“破窗户”（低劣的设计、错误决策、或是糟糕的代码）不修，发现一个就修一个。<br>
如果没有足够的时间进行适当的修理，就用木板把它定起来（或许你可以把出问题的代码放入注释，或是显示“未实现”消息，或是用虚设的数据加以替代）。

如果你发现你的团队和项目的代码十分漂亮——编写整洁、设计良好，并且很优雅——你就很可能会格外注意不去把它弄脏。

#### 3. 石头汤与煮青蛙
**做变化的催化剂。**<br>
**记住大图景。**<br>
要持续不断地观察周围发生的事情，而不只是你自己在做的事情。

#### 4. 足够好的软件
给用户机会，让他们参与决定你所制作的东西何时已足够好。<br>
**使质量成为需求问题。**

不要因为过度修饰和过于求精而损毁完好的程序。

#### 5. 你的知识资产
- 定期投资
- 多元化
- 管理风险
- 低买高卖
- 重新评估和平衡

**定期为你的知识资产投资。**

```
建议：
- 每年至少学习一种新语言。
- 每季度阅读一本技术书籍。
- 也要阅读非技术书籍。
- 上课。
- 参加本地用户组织。
- 试验不同的环境。
- 跟上潮流。
- 上网。
```
**持续投入**十分重要。<br>
把找到答案视为对你个人的挑战。<br>
预先规划，让自己在空闲的片刻时间里总有东西可读。<br>
**批判地分析你读到的和听到的。**<br>
一定要感谢任何回应你的人，如果你看到有人提出你能够解答的问题，尽你的一份力，参与解答。

#### 6. 交流
- 知道你想要说什么 （大纲，简略记下你想要交流的想法，并准备好几种把它们讲清楚的策略。）
- 了解你的听众
  > 你想让他们学到什么？
他们对你讲的什么感兴趣？<br>
他们有多富有经验？<br>
他们想要多少细节？<br>
你想要谁拥有这些信息？<br>
你如何促使他们听你说话？

- 选择时机
- 选择风格
- 让文档美观
- 让听众参与
- 做倾听者
- 回复他人

**你说什么和你怎么说同样重要。**

## 第二章 · 注重实效的途径
#### 7. 重复的危害
DRY（Don't Repeat Yourself）原则：**系统中的每一项知识都必须具有单一、无歧义、权威的表示。**

> 强加的重复 （环境）<br>
无意的重复 （没有意识到）<br>
无耐的重复 （偷懒直接复制代码）<br>
开发者之间的重复 **「让复用变得容易。」**

#### 8. 正交性
**消除无关事物之间的影响。**
- 让你的代码保持解耦
- 避免使用全局数据
- 避免编写相似的函数

#### 9. 可撤销性
**不存在最终决策。**<br>
灵活的架构，为未来编码。

#### 10. 曳光弹
**用曳光弹找到目标。**

#### 11. 原型与便笺
**为了学习而制作原型。**

#### 12. 领域语言
**靠近问题领域编程。**

#### 13. 估算
**估算，以避免发生意外。**<br>
估算项目进度：检查需求；分析风险；设计、实现、集成；向用户确认。<br>
**通过代码对进度表进行迭代。**

## 第三章 · 基本工具
#### 14. 纯文本的威力
**通过纯文本保存知识。**

#### 15. shell 游戏
**利用命令 shell 的力量。**

## 16. 强力编辑
**用好一种编辑器。**

## 17. 源码控制
**总是使用源码控制。**
> Git

#### 18. 调试
**要修正问题，而不是发出指责。**<br>
调试的第一准则：**不要恐慌。**<br>
要总是设法长出问题的根源，而不只是问题的特定表现。<br>
**不要假定，要证明。**

#### 19. 文本操纵
**学习一种文本操纵语言。**

#### 20. 代码生成器
**编写能编写代码的代码。**

## 第四章 · 注重实效的偏执
**你不可能写出完美的软件。**<br>
要防卫性地编码，连自己也不信任。

#### 21. 按合约设计

#### 22. 死程序不说谎
尽早检测问题的好处之一是你可以更早崩溃。<br>
检查每一个可能的错误——特别是意料之外的错误。

#### 23. 断言式编程
**如果它不可能发生，用断言确保它不会发生。**

#### 24. 何时使用异常
**将异常用于异常的问题。**

#### 25. 怎样配平资源
**要有始有终。**<br>
无论是谁分配的资源，他都应该负责解除该资源的分配。

## 第五章 · 弯曲，或折断
#### 26. 解耦与得墨忒尔法则
把你的代码组织成最小组织单位(模块)，并限制它们之间的交互。<br>
**使模块之间的耦合减至最少。**

#### 27. 元程序设计
**要配置，不要集成。**<br>
**将抽象放进代码，细节放进元数据。**<br>
你的代码需要有适应性与灵活性。

#### 28. 时间耦合
容许并发，并考虑解除任何时间或次序上的依赖。<br>
**分析工作流，以改善并发行。**<br>
可以使用像 UML活动图 这样的表示法来捕捉对工作流的描述。<br>
**用服务进行设计。**<br>
必须对任何全局或静态变量加以保护，使其免于并发访问。<br>
**总是为并发进行设计。**

#### 29. 它只是视图
不要把程序写成一个大块，要“分而治之”，把程序分成模块。<br>
**使视图与模型分离。**

#### 30. 黑板
**用黑板协调工作流。**<br>
用黑板协调完全不同的事实和因素，同时又使各参与方保持独立、甚至隔离。

## 第六章 · 当你编码时
保持警觉。
#### 31. 靠巧合编程
**不要靠巧合编程。**
- 总是意识到你在做什么。
- 不要盲目地编程。（构建你不完全理解的应用或是你不熟悉的技术时，容易被巧合误导）
- 按照计划行事。
- 依靠可靠的事物。
- 为你的假定建立文档。（按合约编程）
- 不要只是测试你的代码，还要测试你的假定。
- 为你的工作划分优先级。（把时间花在重要的方面）
- 不要做历史的奴隶。（不要让已有的代码支配将来的代码。如果不再适用，所有的代码都可被替换）

#### 32. 算法速率
`O()`。<br>
**估算你的算法的阶。**<br>
**测试你的估算。**

#### 33. 重构
重写、重做和重新架构代码合起来，称为重构。

无论代码具有下面哪些特征时，都应该考虑重构代码：
- 重复。
- 非正交的设计。
- 过时的知识。
- 性能。

**早重构，常重构。**<br>
重构就是重新设计。

重构的提示：<br>
1. 不要试图在重构的同时增加功能。<br>
2. 在开始重构之前，确保你拥有良好的测试。尽可能经常运行这些测试。<br>
3. 采取短小、深思熟虑的步骤。并在每个步骤之后进行测试。

#### 34. 易于测试的代码
**为测试而设计。**<br>
当你设计模块、甚或是单个例程时，你应该既设计其合约，也设计测试该合约的代码。<br>
注意考虑边界条件。

测试装备应具有的功能：
- 用以指定设置与清理的标准途径
- 用以选择个别或所有可用测试的方法
- 分析输出是否是预期（或意外）结果的手段
- 标准化的故障报告形式

测试应该是可组合的，测试可以从子组件的子测试组合到任意深度。

即兴测试：在测试过程中，临时创建一些特定的测试。<br>
在调试的最后，需要使即兴测试正式化。

**测试你的软件，否则你的用户就得测试。**

#### 35. 邪恶的向导
**不要使用你不理解的向导代码。**

## 第七章 · 在项目开始之前
#### 36. 需求之坑
**不要搜集需求——挖掘它们。**<br>
**与用户一同工作，以像用户一样思考。**<br>
**抽象比细节活得更长久。**<br>
项目文档需要能够准确、完整地记录需求增长是怎样及何时发生的。<br>
**使用项目词汇表。**<br>
把需求制作成超文本文档，我们可以给每个读者他们想要的东西。

#### 37. 解开不可能解开的谜题
解开谜题的关键在于确定加给你的各种约束，并确定你确实拥有的自由度。<br>
**不要在盒子外面思考——要找到盒子。**

如果觉得自己在处理的问题很难，问问自己以下的问题：
- 有更容易的方法吗？
- 你是在设法解决真正的问题。还是被外围的技术问题转移了注意力？
- 这件事情为什么是一个问题？
- 是什么使它如此难以解决？
- 它必须以这种方式完成吗？
- 它真的必须完成吗？

#### 38. 等你准备好
**倾听反复出现的疑虑——等你准备好再开始。**<br>
构建原型：选择一个你觉得会有困难的地方，开始进行某种“概念验证”。

#### 39. 规范陷阱
**对有些事情“做”胜于“描述”。**<br>
你应该倾向于把需求搜集、设计、以及实现视为交付高质量的系统的不同方面。<br>
如果没有构建原型，在规范之上构建另外一层规范时要小心。

#### 40. 圆圈与箭头
**不要做形式方法的奴隶。**<br>
批判地看待方法学，并从各种方法学中提取精华，融合成每个月都在变得更好的一套工作习惯。<br>
**昂贵的工具不一定能制作出更好的设计。**

## 第八章 · 注重实效的项目
#### 41. 注重实效的团队
- 不要留破窗户
- 主动地监视环境的变化
- 交流
  > 一个简单都营销诀窍，能帮助团队作为整体与外界交流：创建品牌。在与别人交谈时，大方地使用你的团队地名字。
- 不要重复你自己，指定多个成员负责工作的各个方面
- 正交性
  **围绕功能、而不是工作职务进行组织。**
- 自动化

#### 42. 无处不在的自动化
**不要使用手工流程。**<br>
人的可重复性并不像计算机那么好。
> 自动化工具：cron —— 自动安排备份、夜间构建、网站维护、以及其它任何可以无人照管地完成的事情。

- 项目编译
- 生成代码
- 回归测试
- 构建自动化
  - 项目构建的步骤：
    1. 从仓库中签出源码；
    2. 从头开始构建项目（每次构建都会标注某种形式的发布或版本号，或是日期戳）；
    3. 创建可分发映像；
    4. 运行规定的测试。
- 自动化管理
  维持自动、无人照管、内容驱动的工作流。
  - 网站生成
  - 批准流程

#### 43. 无情的测试
**早测试，常测试，自动测试。**<br>
“编一点，测一点。”<br>
**要到通过全部测试，编码才算完成。**

- 测试什么
  - 单元测试
    如果各组成部分自身不能工作，它们结合在一起多半也不能工作。
  - 集成测试
    说明组成项目的主要子系统能工作，并且能很好地协同。
  - 验证和校验
    它满足系统的功能需求吗？
  - 资源耗尽、错误及恢复
  - 性能测试
  - 可用性测试
    软件对于用户，就像是手的延伸吗？
  - ……
- 怎样测试
  - 回归测试
    把当前测试的输出与先前的(或已知的)值进行对比。确定今天对 bug 的修正没有破坏昨天可以工作的代码。
  - 测试数据
    现实世界的数据和合成的数据。
  - 演练 GUI 系统
  - 对测试进行测试
    **通过“蓄意破坏”测试你的测试。**
  - 彻底测试
    **测试状态覆盖，而不是代码覆盖。**
- 何时测试
  任何产品代码一旦存在，就需要进行测试。
  大多数测试都应该自动完成。
  **一个 bug 只抓一次。**
  一旦测试人员找到了某个 bug，这应该是测试人员最后一次发现这个 bug，应该对自动化测试进行修改，从此每次都检查那个特定的 bug。

#### 44. 全都是写
*要把文档当作整个开发过程的完整组成部分加以接受。*<br>
不进行重复劳动，不浪费时间，并且把文档放在手边——如果可能，就放在代码本身中。<br>
**把英语当作又一种编程语言。**<br>
**把文档建在里面，不要拴在外面。**

- 代码中的注释
  注释应该讨论为何要做某事、它的目的和目标。
  变量名应该精心选择，并且有意义。要全拼不要缩写。
  - 不应出现在源码注释中的一些内容：
    - 文件中的代码导出的函数的列表。
    - 修订历史。（在注释中包括最后更改日期和更改人的信息可能是有用的）
    - 该文件使用的其它文件的列表。
    - 文件名。

发布出的书面文档被制作成能够在 Web 上在线发布的形式，用超链接整合在一起。注意，要在每个网页上放上日期戳或版本号。

#### 45. 极大的期望
项目的成功是由它在多大程度上满足了用户的期望来衡量的。<br>
**温和地超出用户的期望。**<br>
与用户一同工作，达成对开发过程和最终产品、以及他们尚未描述出来的期望的共同理解。

- 额外的一公里
  给用户的东西要比他们期望的多一点。
  - 相对容易地增加、并让一般用户觉得很好的特性包括：
    - 气球式帮助或工具提示帮助
    - 快捷键
    - 作为用户手册的补充材料的快速参考指南
    - 彩色化
    - 日志文件分析器
    - 自动化安装
    - 用于检查系统完整性的工具
    - 运行系统的多个版本、以进行培训的能力
    - 为他们的机构定制的初始动画

#### 46. 傲慢与偏见
不会逃避责任。<br>
乐于接受挑战，乐于使我们的专业知识广为人知。<br>
**在你的作品上签名。**<br>
“这是我编写的，我对自己的工作负责。”

做一个注重实效的程序员。
<br><hr>

##### ☞ 两个世界级的程序员专业协会：
- Association for Computing Machinery （ACM）
- IEEE Computer Society

<hr>

📚 链接：[https://pan.baidu.com/s/16gDlDoGo9ViTl2PcZHFkZQ](https://pan.baidu.com/s/16gDlDoGo9ViTl2PcZHFkZQ)；  密码：yy4j
